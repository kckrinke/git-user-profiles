#!/usr/bin/env perl
## git-user-profiles-admin - Manipulate git user profiles.
## Author: Kevin C. Krinke <kevin@krinke.ca>
## Copyright: GPLv2
use strict;
use warnings;
use constant { true => 1, false => 0 };
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use File::Path;
use File::Copy;

my $opt_usage = false;
my $opt_help = false;
our $opt_profile_path = '/etc/git-user-profiles.d';
GetOptions
 ( 'h|?' => \$opt_usage,
   'help' => \$opt_help,
   'p|profile|profile-path=s' => \$opt_profile_path
 ) or pod2usage(1);
pod2usage(0) if $opt_usage;
pod2usage(-exitval => 0, -verbose => 2) if $opt_help;

mkdir($opt_profile_path) unless -d $opt_profile_path;
unless (-w $opt_profile_path) {
    pod2usage
     ( -exitval => 0,
       -verbose => 0,
       -message => "Insufficient privileges for: ".$opt_profile_path
     );
}

use File::Slurp;
use UI::Dialog::Console;
our $DIALOG =
 new UI::Dialog::Console
 ( backtitle => "GIT User Profiles Admin",
   height => 20, width => 40, listheight => 10,
 );


exit(main_menu());

## Helper function to query a string from the end user, with an optional
## regular expression to match against. Prompts for confirmation.
sub do_input_check {
    my ($title,$message,$default,$regex) = (undef,undef,undef,undef);
    if (@_ == 4) {
        ($title,$message,$default,$regex) = @_;
    } else {
        ($title,$message,$default) = @_;
    }
    my $response = undef;
    while (not defined $response) {
        $response = $DIALOG->inputbox
         ( "title" => "${title}",
           "text" => "${message}",
           "entry" => "${default}"
         );
        if ($DIALOG->state() eq "OK") {
            if (defined $regex) {
                unless ($response =~ $regex) {
                    $DIALOG->msgbox(text=>'"'.$response.'" did not match the pattern: "'.$regex.'".');
                    $default = $response;
                    $response = undef;
                    next;
                }
            } else {
                last;
            }
        } else {
            $response = undef;
            last;
        }
    }
    if (defined $response) {
        my $conf_resp = $DIALOG->yesno
         ( "title" => "Confirm: ${title}",
           "text" => "You entered \"${response}\", is this correct?",
         );
        if ($DIALOG->state() eq "OK") {
            return $response;
        }
    }
    return undef;
}

sub select_profile {
    my ($message) = @_;
    opendir(my $dh, $opt_profile_path)
     || die "can't read path $opt_profile_path: $!";
    my @profiles = grep { !m/^\./ && -f "$opt_profile_path/$_" } readdir($dh);
    closedir $dh;
    my @list = ();
    foreach my $username (@profiles) {
        my $profile = read_profile($username);
        push(@list,$username,$profile->{name});
    }
    my $selection = $DIALOG->menu
     ( "title" => "Profile Selection",
       "text" => $message,
       "list" => \@list
     );
    if ($DIALOG->state() eq "OK") {
        return $selection;
    }
    return undef;
}

sub read_profile {
    my ($username) = @_;
    my $profile_path = $opt_profile_path.'/'.$username;
    if (-f $profile_path) {
        my $raw = read_file($profile_path);
        my @lines = split(m!\r??\n!,$raw);
        my %profile = ( user => $username );
        $profile{_lines} = \@lines;
        ($profile{created}) = grep { m!^#\sCreated\:! } @lines;

        foreach my $line (@lines) {
            next if $line =~ m!^#!;
            if ($line =~ m!^export\s(GUP_.+?)="([^"]+?)"\s*!) {
                my ($key,$val) = ($1,$2);
                $profile{$key} = $val;
            } else {
                # unkown line format?
            }
        }

        return \%profile;
    }
    return undef;
}

sub write_profile {
    my ($username,$fullname,$email,$skey) =
     ( @_ == 3 ) ? ( $_[0], $_[1], $_[2], "" ) : @_;
    my $content = '';
    my $date_now = localtime();
    my $profile_path = $opt_profile_path.'/'.$username;
    my $profile = read_profile($username);
    if (defined $profile) {
        $content .= "# DO NOT EDIT THIS FILE BY HAND\n";
        $content .= $profile->{_lines}[0]."\n";
        $content .= '# Updated: '.localtime()."\n";
    } else {
        $content .= "# DO NOT EDIT THIS FILE BY HAND\n";
        $content .= '# Created: '.localtime()."\n";
    }
    $content .= "export GUP_USER_NAME=\"".$fullname."\"\n";
    $content .= "export GUP_USER_EMAIL=\"".$email."\"\n";
    $content .= "export GUP_USER_SKEY=\"".$skey."\"\n";
    write_file($profile_path,$content);
}

sub add_menu {
    my $username = do_input_check
     ( "Add Profile: User Name",
       "What is the unix username? (alphanumeric only, no spaces, starts with a letter)",
       $ENV{USER},
       qr!^[a-z][a-z0-9]+?$!
     );
    # early out if profile undef, means user canceled
    return false unless defined $username;
    if (-f $opt_profile_path.'/'.$username) {
        $DIALOG->msgbox
         ( text => 'Profile '.$username.' exists already. Please try again with a different profile name or edit the existing one.' );
        return false;
    }
    my $fullname = do_input_check
     ( "Add Profile: Full Name",
       "What is the user's full name?",
       ""
     );
    unless (defined $fullname) {
        $DIALOG->msgbox( text => "Full name is required." );
        return false;
    }
    my $email = do_input_check
     ( "Add Profile: Email Address",
       "What is the user's email address?",
       "",
       qr!^[a-z][-._a-z0-9]+?\@[a-z][-._a-z0-9]+?\.[a-z]+?$!
     );
    unless (defined $email) {
        $DIALOG->msgbox( text => "Email address is required." );
        return false;
    }
    my $skey = do_input_check
     ( "Add Profile: Signing Key ID",
       "What is the user's PGP Key ID? (blank for none)",
       "",
       qr!^(?:0x)??[0-9a-fA-F]*$!
     );
    write_profile($username,$fullname,$email);
    return true;
}

sub del_menu {
    my $username = select_profile("Select a profile to delete:");
    if (defined $username) {
        my $profile_path = $opt_profile_path.'/'.$username;
        if ($DIALOG->yesno(text=>"Are you sure you want to delete the \"${username}\" profile?")) {
            unlink($profile_path);
            return true;
        }
    }
    return false;
}

sub rename_menu {
    my $old_name = select_profile("Select a profile to rename:");
    if (defined $old_name) {
        my $old_path = $opt_profile_path.'/'.$old_name;
        my $new_name = $DIALOG->inputbox
            ( text => "What would you like to rename \"${old_name}\" profile to?",
              title => "Rename ${old_name}",
              entry => "${old_name}"
            );
        if ($DIALOG->state() eq "OK") {
            if ($old_name ne $new_name) {
                my $new_path = $opt_profile_path.'/'.$new_name;
                unless (move($old_path,$new_path)) {
                    $DIALOG->msgbox
                     ( "Error",
                       "Failed to move \"$old_path\" to \"$new_path\": $!",
                     );
                }
            }
        }
    }
    return false;
}

sub edit_menu {
    my $username = select_profile("Select a profile to edit:");
    if (defined $username) {
        my $profile_path = $opt_profile_path.'/'.$username;
        my $profile = read_profile($username);
        unless (defined $profile) {
            die "GUP: not sure how we got here.";
        }
        my $fullname = do_input_check
         ( "Edit Profile: Full Name",
           "What is the user's full name?",
           $profile->{GUP_USER_NAME}
         );
        unless (defined $fullname) {
            $DIALOG->msgbox( text => "Full name is required." );
            return false;
        }
        my $email = do_input_check
         ( "Edit Profile: Email Address",
           "What is the user's email address?",
           $profile->{GUP_USER_EMAIL},
           qr!^[a-z][-._a-z0-9]+?\@[a-z][-._a-z0-9]+?\.[a-z]+?$!
         );
        unless (defined $email) {
            $DIALOG->msgbox( text => "Email address is required." );
            return false;
        }
        my $skey = do_input_check
         ( "Edit Profile: Signing Key ID",
           "What is the user's PGP Key ID? (blank for none)",
           $profile->{GUP_USER_SKEY},
           qr!^(?:0x)??[0-9a-fA-F]*$!
         );
        write_profile($username,$fullname,$email,$skey);
        return true;
    }
    return false;
}

sub main_menu {
    my $response = $DIALOG->menu
     ( title => "Main Menu",
       list =>
       [ "Add", "Create a new profile",
         "Edit", "Change an existing profile",
         "Rename", "Rename an existing profile",
         "Delete", "Remove existing profile",
         "Quit", "Exit this program"
       ]
     );
    if ($DIALOG->state() eq "OK") {
        add_menu() if $response eq "Add";
        edit_menu() if $response eq "Edit";
        rename_menu() if $response eq "Rename";
        del_menu() if $response eq "Delete";
        return false if $response eq "Quit";
        return main_menu();
    }
    return false;
}

__END__

=head1 NAME

git-user-profiles-admin - Administer GIT User Profiles

=head1 SYNOPSIS

git-user-profiles-admin [options]

 Options:
   -h -?              Brief usage details
   --help             Full documentation
   --profile=/path    Path to the git user profiles directory

=head1 OPTIONS

=over 8

=item B<-h|-?>

Print a brief help message and exits.

=item B<--help>

Prints the full manual page and exits.

=item B<--profile=/path>

Allows the user to specify a custom path to the tracked git user
profiles. This defaults to: B</etc/git-user-profiles.d>

=back

=head1 DESCRIPTION

This helper script enables users with write access to the git user
profiles directory (see --profile) to add, edit and remove profiles.

=head1 COPYRIGHT & LICENSE

git-user-profiles-admin - Administer GIT User Profiles
Copyright (c) 2014  Kevin C. Krinke <kevin@krinke.ca>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

=cut
